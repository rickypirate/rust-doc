rust 特点记录

以cargo作为文件管理器
cargo new example --bin为新建项目,即是二进制的程序，而非库
会产生文件如下：Cargo.toml和一个src目录，并且初始化了一个Git仓库
在cargo.toml之中，标题以及以后的内容都属于同一部分，直到下一个标题开始，标题以[example]开始
使用crate时候，需要事先在cargo.toml中注册crate，在dependencies，格式为 cratename ="1.8.9"



cargo build 会产生一个Cargo.lock新文件，永远不要碰这个文件
cargo run 编译并运行文件
cargo check检查代码的可编译性，但是并不编译
cargo build --release构建需要发布的程序，需要优化，所以时间较build时间长
cargo update会更新所以来的版本，更新完成以后会自动添加在cargo.lock之中，大版本更新需要手动显示在toml之中修改dependencies

使用crate需要使用extern crate name;
单纯编译一个文件用rustc即可

rust文件以.rs结尾

少量类型已经在prelude被引入，其他未被引入的类型需要使用use显示地引入
使用use将命名空间引入作用域，use语句结尾也需要“;”做结束符号
实际上除了struct成员变量结尾以“,”结尾，还有元组，枚举成员，以及某些简化了的闭包函数不需要结尾，其他都是以分号结尾
简短闭包声明如下：
    fn fnname (x:u32)->u32{x+1}
    除了上述这个闭包类型外，其他都要加上“;”结尾

rust 用Result处理错误，Result是一个enum，其成员是Ok和Err。Result成员拥有expect方法，Ok成员调用返回Ok成员的值，Err调用会导致程序崩溃

let是创建变量，和绑定变量值并不是一个概念，这一点需要注意
变量除非显示用mut修饰，否则默认不可变，常量用const修饰，且不能用mut修饰
变量可以隐藏，只要再用let创建一个同名的变量即可隐藏同名的变量
同一作用域中，只能有一个mut或者&mut，以防止数据竞争
let修饰的变量经常可以推断出变量类型，所以经常省略类型，而有时类型推断会有歧义，则需要明确指出类型编译器才能识别你想要的类型

rust只有两个原生的复合类型元组和数组，元组可存放不同类型，而数组只能存放同类型
元组访问直接在名称后面.index即可访问
数组需要[index]

语句和表达式区别：语句返回计算并产生值，而表达式不会如此
函数的最后一个表达式就是返回值，此时不需要return，也不需要分号结尾

let创建变量可以跟if语句，根据条件绑定变量，但是重要的是，所有条件语句中的返回值都必须类型一致
loop循环，需要在语句体中用break指定条件停止

使用for e in iterator迭代，iter()返回不可变引用的迭代器，iter_into()返回所有权的迭代器，iter_mut()返回可变引用的迭代器
range也是迭代器，其格式如此：(1..10)，从1到9，不包括10，注意一下

rust浅拷贝深拷贝，拷贝指针而不拷贝其指向的数据，是为浅拷贝，都拷贝则为深拷贝，含引用或指针的对象需要实现特定的copy trait来实现深拷贝
如没有实现copy trait，则对象赋值为移动，移动即是所有权转让，被移动的对象丧失所有权作废，无法再被使用，可通过clone()实现数据深拷贝

变量必须mut，引用才能mut，且一个作用域中有且只有一个mut引用，但可有多个普通引用
引用的生命周期必须小于被引用变量

slice是一段数据的引用，拥有的仅是引用，并无所有权。其类型为&[T],可由以下几种方式产生：
&array[2..9] &array[..9] &array[0..] &array[..]

rust most important features:1、所有权系统 2、生命周期 3、trait 4、模式


模式：模式匹配默认会使用copy trait，如果对象没有实现则会转移对象所有权，此特性与闭包相反，闭包默认获取环境对象的引用，使用move才能强制转移所有权

类型转换：引用转指针是安全操作，只要不去解引用裸指针就是安全的，相反，裸指针转引用是unsafe的。as转换只允许安全转换，transmute允许不安全转换

强制转换是隐式的，以下转换时允许的：
    &mut ——》&
    *mut T ——》*const T
    & ——》*
Deref trait 相当于*操作，可以自定义强转，Target=type，并且强转类型是&type
 
访问和修改静态变量是不安全操作

trait对象：
方法静态分发，即函数通过对象调用对象方法，编译器会生成静态代码，效率较高
方法动态分发，即函数通过引用as转换或者强制转型实现动态分发（为什么用指针）保证代码能对其他类型正常运作，因为实现trait的对象是任意大小的，用trait对象作为形参接受实参，函数则不能通用，指针则可以通用

也并不是所有trait对象都可以作为对象类型，他必须是安全的trait才可以。方法是对象安全的才是安全trait。一要求方法没有任何类型参数，二要求方法没有self参数

函数指针和闭包的区别就是，函数指针不包含环境变量

关联类型是定义trait通用性操作的，type Item=B，在trait方法函数里，用&Self::Item替代B类型（注意，S是大写，Self用于指代当前对象类型）
type Target=A，Deref trait的操作，用于重载*操作，自定义强制转换的目标类型

unsafe类型有以下几种：
    1、unsafe fn
    2、unsafe {}
    3、unsafe trait
    4、unsafe impl
    
省略的生命周期的推断策略：
    1、每个被省略的生命周期的函数参数，其生命周期都是不一样的
    2、只有一个输入生命周期，那么这个函数返回值的生命周期则是这个被输入的参数的生命周期
    3、如果多个输入生命周期，其中存在self，省略生命周期的输出则是self的生命周期
    
Rc<T>可被多个绑定持有，但是用于单线程，std::rc::Rc
Rc对象clone()只会增加引用计数，一般习惯上用Rc::clone(&t),而t.clone()也是一样的


RefCell也是只适用于单线程，用于在外部认为是不可变的的情况下改变对象内部
RefCell<T>在外部不可变的情况下，有两种方法获取其引用，T.borrow_mut()获取可变引用，T.borrow()获取普通引用
Cell 模拟对象字段的可变性，用Cell.set()改变值
其规则适用于普通对象的引用规则，即任何情况下只能有一个可变引用，或者多个不可变引用


模式中的特点：
    1 匹配 （最常见） 2 匹配范围 0..10 3 多重匹配A | B 4 绑定 e@0..10 5 解构 6 守卫 if 7 忽略 _ 8 引用绑定 ref a ref mut b 

trait特点：
    trait A:B 表示A用到B的方法，实现trait A的前提是实现 trait B
    trait可以有默认实现，类似Java abstract class
    
    trait bound <T:A+B,U:B+C>(a:T,b:U) 还可以在这样写 <T,U>(a:T,b:U)where T:A+B,U:B+C
    
    
    不同trait的同名方法名的歧义消除,对象C同时实现了A B trait，rust根据self的类型选择具体实现：
    A::do(&C);
    B::do(&C);
    如果方法是关联函数呢？<C as A>::do()调用C的A实现，<C as B>::do()调用C的B实现

生命周期限定
    's:'c,表示s的周期大于等于c
    'static 保证周期存在于整个程序
    无论是方法函数还是对象，所有输出的生命周期必须不能大于输入
    
