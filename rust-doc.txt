rust 特点记录

以cargo作为文件管理器
cargo new example --bin为新建项目,即是二进制的程序，而非库
会产生文件如下：Cargo.toml和一个src目录，并且初始化了一个Git仓库
在cargo.toml之中，标题以及以后的内容都属于同一部分，直到下一个标题开始，标题以[example]开始
使用crate时候，需要事先在cargo.toml中注册crate，在dependencies，格式为 cratename ="1.8.9"



cargo build 会产生一个Cargo.lock新文件，永远不要碰这个文件
cargo run 编译并运行文件
cargo check检查代码的可编译性，但是并不编译
cargo build --release构建需要发布的程序，需要优化，所以时间较build时间长
cargo update会更新所以来的版本，更新完成以后会自动添加在cargo.lock之中，大版本更新需要手动显示在toml之中修改dependencies

使用crate需要使用extern crate name;
单纯编译一个文件用rustc即可

rust文件以.rs结尾

少量类型已经在prelude被引入，其他未被引入的类型需要使用use显示地引入
使用use将命名空间引入作用域，use语句结尾也需要“;”做结束符号
实际上除了struct成员变量结尾以“,”结尾，还有元组，枚举成员，以及某些简化了的闭包函数不需要结尾，其他都是以分号结尾
简短闭包声明如下：
    fn fnname (x:u32)->u32{x+1}
    除了上述这个闭包类型外，其他都要加上“;”结尾

rust 用Result处理错误，Result是一个enum，其成员是Ok和Err。Result成员拥有expect方法，Ok成员调用返回Ok成员的值，Err调用会导致程序崩溃

let是创建变量，和绑定变量值并不是一个概念，这一点需要注意
变量除非显示用mut修饰，否则默认不可变，常量用const修饰，且不能用mut修饰
变量可以隐藏，只要再用let创建一个同名的变量即可隐藏同名的变量
同一作用域中，只能有一个mut或者&mut，以防止数据竞争
let修饰的变量经常可以推断出变量类型，所以经常省略类型，而有时类型推断会有歧义，则需要明确指出类型编译器才能识别你想要的类型

rust只有两个原生的复合类型元组和数组，元组可存放不同类型，而数组只能存放同类型
元组访问直接在名称后面.index即可访问
数组需要[index]

语句和表达式区别：语句返回计算并产生值，而表达式不会如此
函数的最后一个表达式就是返回值，此时不需要return，也不需要分号结尾

let创建变量可以跟if语句，根据条件绑定变量，但是重要的是，所有条件语句中的返回值都必须类型一致
loop循环，需要在语句体中用break指定条件停止

使用for e in iterator迭代，iter()返回不可变引用的迭代器，iter_into()返回所有权的迭代器，iter_mut()返回可变引用的迭代器
range也是迭代器，其格式如此：(1..10)，从1到9，不包括10，注意一下

rust浅拷贝深拷贝，拷贝指针而不拷贝其指向的数据，是为浅拷贝，都拷贝则为深拷贝，含引用或指针的对象需要实现特定的copy trait来实现深拷贝
如没有实现copy trait，则对象赋值为移动，移动即是所有权转让，被移动的对象丧失所有权作废，无法再被使用，可通过clone()实现数据深拷贝

变量必须mut，引用才能mut，且一个作用域中有且只有一个mut引用，但可有多个普通引用
引用的生命周期必须小于被引用变量

slice是一段数据的引用，拥有的仅是引用，并无所有权。其类型为&[T],可由以下几种方式产生：
&array[2..9] &array[..9] &array[0..] &array[..]


